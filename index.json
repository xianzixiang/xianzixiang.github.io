[{"authors":["admin"],"categories":null,"content":"Zixiang Xian is a master student of Machine Learning at Concordia University AI Lab. His research interests include Machine Learning and Computer Vision. He is under the supervision of Professor Nizar Bouguila.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1582962603,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://faithio.cn/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Zixiang Xian is a master student of Machine Learning at Concordia University AI Lab. His research interests include Machine Learning and Computer Vision. He is under the supervision of Professor Nizar Bouguila.","tags":null,"title":"Zixiang Xian","type":"authors"},{"authors":["zi_xian"],"categories":null,"content":"Xian Zixiang is a master student of Machine Learning at Concordia University AI Lab. His research interests include Machine Learning and Computer Vision. He is under the supervision of Professor Nizar Bouguila.\nBefore his graduate study, he is a senior backend engineer at Kingsoft Company, skilling at Golang, Java, JavaScript, and Python.\nHe is so motivative and passion for exploring the new world of computer science.\nFeel free to contact me.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1582962603,"objectID":"b531f07f2ad34c1997a37315504c48d8","permalink":"https://faithio.cn/authors/zi_xian/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/zi_xian/","section":"authors","summary":"Xian Zixiang is a master student of Machine Learning at Concordia University AI Lab. His research interests include Machine Learning and Computer Vision. He is under the supervision of Professor Nizar Bouguila.\nBefore his graduate study, he is a senior backend engineer at Kingsoft Company, skilling at Golang, Java, JavaScript, and Python.\nHe is so motivative and passion for exploring the new world of computer science.\nFeel free to contact me.","tags":null,"title":"XIAN ZIXIANG","type":"authors"},{"authors":[],"categories":[],"content":"Approximate Inference.pdf\nApproximate Inference.html\n","date":1584656517,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584657777,"objectID":"42e77f450ce9f46625dae22d128fa311","permalink":"https://faithio.cn/post/approximate-inference/","publishdate":"2020-03-19T18:21:57-04:00","relpermalink":"/post/approximate-inference/","section":"post","summary":"Approximate Inference.pdf\nApproximate Inference.html","tags":[],"title":"Approximate Inference","type":"post"},{"authors":[],"categories":[],"content":"Exponential.pdf\nExponential.html\n","date":1584656503,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584657777,"objectID":"b00c82fc12ffaf3b2f6fd5dba8d770b8","permalink":"https://faithio.cn/post/the-exponential-family/","publishdate":"2020-03-19T18:21:43-04:00","relpermalink":"/post/the-exponential-family/","section":"post","summary":"Exponential.pdf\nExponential.html","tags":[],"title":"The Exponential Family","type":"post"},{"authors":[],"categories":[],"content":"","date":1584654998,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584657777,"objectID":"97dc121d7ddd7c67d1b89d3e4f7cf1a1","permalink":"https://faithio.cn/post/probabilistic-graphical-model/","publishdate":"2020-03-19T17:56:38-04:00","relpermalink":"/post/probabilistic-graphical-model/","section":"post","summary":"","tags":[],"title":"Probabilistic Graphical Model","type":"post"},{"authors":[],"categories":[],"content":"When I run some python code from github, it occur the following problem as screenshot.\n RuntimeError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends. If you are using (Ana)Conda please install python.app and replace the use of \u0026lsquo;python\u0026rsquo; with \u0026lsquo;pythonw\u0026rsquo;. See \u0026lsquo;Working with Matplotlib on OSX\u0026rsquo; in the Matplotlib FAQ for more information.\n Solution:(https://stackoverflow.com/questions/21784641/installation-issue-with-matplotlib-python)\nProblem Cause In mac os image rendering back end of matplotlib (what-is-a-backend to render using the API of Cocoa by default). There is Qt4Agg and GTKAgg and as a back-end is not the default. Set the back end of macosx that is differ compare with other windows or linux os.\nI resolve this issue following ways:\n I assume you have installed the pip matplotlib, there is a directory in you root called ~/.matplotlib. Create a file ~/.matplotlib/matplotlibrc there and add the following code: backend: TkAgg  From this link you can try different diagram.\n","date":1583775429,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583802329,"objectID":"f401314725b6ff0b004bf2f679a80813","permalink":"https://faithio.cn/post/run-issue-with-matplotlib-in-mac-os-x/","publishdate":"2020-03-09T13:37:09-04:00","relpermalink":"/post/run-issue-with-matplotlib-in-mac-os-x/","section":"post","summary":"When I run some python code from github, it occur the following problem as screenshot.\n RuntimeError: Python is not installed as a framework. The Mac OS X backend will not be able to function correctly if Python is not installed as a framework. See the Python documentation for more information on installing Python as a framework on Mac OS X. Please either reinstall Python as a framework, or try one of the other backends.","tags":[],"title":"Run Issue With Matplotlib in Mac OS X","type":"post"},{"authors":[],"categories":[],"content":" Math Formula Factor graphs Shows how a function of several variables can be factored into a product of simpler functions.\n $$ f(x,y,z) = (x+y) \\cdot (y + z) \\cdot (x +z) $$\n Very useful for representing posteriors.\n$ $$ P(x1, ..., x_n) = P(x_1) \\Pi P( x_i | x_{i-1} ) $$ $\n$$ P(m|x1, \u0026hellip;, x_n) = P(m) \\cdot \\Pi P(x_i|m)$$\nmodeling  What graph should I use for this data?  Inference  Given the graph and data, what is the mean of x algorithm  Sampling Variable elimination Message-passing(Expectation Propagation, Variational Bayes)   Cutter problem  Want to estimate x given multiple y\u0026rsquo;s $$ p(x) = \\mathcal{N}(x; 0, 100) $$ $$ p(y_i|x) = (0.5)\\mathcal{N}(y_i; x, 1) + (0.5)\\mathcal{N} (y_i;0,10)$$  -\u0026gt; $ P(x|y1, \u0026hellip;, y_n) = P(x) \\cdot \\Pi P(y_i|x)$\nif we only have 2 points:\n$$ P(x) \\cdot P(y_1|x) \\cdot P(y_2|x) \\rightarrow p(y_i|x) = (0.5)\\mathcal{N}(y_i; x, 1) + (0.5)\\mathcal{N} (y_i;0,10)$$\n2 points have 4 Gaussians -\u0026gt; N points $$2^N$$ Gaussians\n https://zhuanlan.zhihu.com/p/75617364 $$ p(z | w)=\\frac{p(w | z) p(z)}{p(w)}=\\frac{p(w | z) p(z)}{\\int_{z} p(w | z) p(z) d z} $$ Because it extends belief propagation. Belief propagation passes the entire distribution is the message. While EP will only pass onto the distribution certain expectation distribution allows you to you get a very compact message.\n Expectation Propagation  Fits an exponential-family approximation to the posterior. Belief propagation is a special case Kalman filtering is a special case Does not always converge.  May get stuck due to improper distributions May oscillate due to loopy graph   AGM $ $$ p(\\mathbf{X} | \\Theta)=\\sum_{j=1}^{M} p_{j} p\\left(\\mathbf{X} | \\xi_{j}\\right) $$ $\n $\\xi_j$ is the set of the parameters of component j. $ p_j$ are the mixing proptions which must be positive and sum to one. $\\Theta = {p_1, \\ldots, p_M, \\xi_1, \\ldots, \\xi_M}$ is the complete set of parameters fully characterizing the mixture. $ M \\geq 1$ is number of components in the mixture.  $ $$ p\\left(\\vec{X} | \\theta_{j}\\right)=\\prod_{d=1}^{D} \\sqrt{\\frac{2}{\\pi}} \\frac{1}{\\left(\\sigma_{l_{j d}}+\\sigma_{r_{j d}}\\right)} \\times\\left\\{\\begin{array}{ll}\\exp \\left[-\\frac{\\left(X_{d}-\\mu_{j d}\\right)^{2}}{2 \\sigma_{l_{j d} }^{2}}\\right] \u0026amp; \\text { if } X_{d}\u0026lt;\\mu_{j d} \\\\ \\exp \\left[-\\frac{\\left(X_{d}-\\mu_{j d}\\right)^{2}}{2 \\sigma_{r_{j d}}^{2}}\\right] \u0026amp; \\text { if } X_{d} \\geq \\mu_{j d}\\end{array}\\right. $$ $\n $\\xi_{j}=\\left(\\vec{\\mu}_{j}, \\vec{\\sigma}_{l_{j}}, \\vec{\\sigma}_{r_{j}}\\right)$ is the set of the parameters of components $j$ $\\vec{\\mu}_{j}=\\left(\\mu_{j 1}, \\ldots, \\mu_{j D}\\right)$ is the mean $\\vec{\\sigma}_{l_{j}}=\\left(\\vec{\\sigma}_{l_{j 1}}, \\ldots, \\vec{\\sigma}_{l_{j D}}\\right)$ is the left standard deviation $\\vec{\\sigma}_{r_{j}}=\\left(\\vec{\\sigma}_{r_{j 1}}, \\ldots, \\vec{\\sigma}_{r_{j D}}\\right)$ is the right standard deviation  $$ p\\left(\\theta_j | \\vec{X} \\right)= \\frac{p(\\theta_j)\\times p\\left(\\vec{X} | \\thetaj\\right)}{p(\\vec{X})} = \\frac{1}{p(\\vec{X})} \\prod{i} f_{i}(\\boldsymbol{\\theta}) $$\n$$ p(\\vec{X})= \\int \\prod{i} f{i}(\\boldsymbol{\\theta}) \\mathrm{d} \\boldsymbol{\\theta} $$\nHere, $p(\\vec{X})$ is very intractable to calculate and we don\u0026rsquo;t know $ f_{i}(\\boldsymbol{\\theta}) $.\nNow we consider using EP. The approximation, $q\\left(\\theta_j \\right)$ , of the posterior, $p\\left( \\theta_j | \\vec{X} \\right)$ , is assumed to have same functional form. $$ q(\\theta_j)=\\frac{1}{Z} \\prod_i \\widetilde{f}_i(\\theta_j) $$\nin which each factor $\\widetilde{f}_i(\\theta_j)$ in the approximation corresponds to one of the factors $f_i(\\theta_j)$ in the true posterior. $\\widetilde{f}_i(\\theta_j) $ is a asymetric Gaussian.\n$$ p(\\mathbf{X} | \\boldsymbol{\\theta})=(1-w) \\mathcal{A}(\\mathbf{X} | \\boldsymbol{\\theta}, \\mathbf{I_l}, \\mathbf{I_r})+w \\mathcal{A}(\\mathbf{X} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{I_r}) $$\nwhere w is the proportion of background clutter. And the prior over $\\mathbf{\\theta}$(mean) is taken to be Asymmetric Gaussian.\nAnd $$ p(\\boldsymbol{\\theta})= \\mathcal{A}(\\mathbf{X} | \\mathbf{0}, b \\mathbf{I_l}, b \\mathbf{Ir}) $$ $$ p(\\mathcal{X}, \\boldsymbol{\\theta})=p(\\boldsymbol{\\theta}) \\prod{n=1}^{N} p\\left(\\mathbf{x}_{n} | \\boldsymbol{\\theta}\\right) $$\n1. initialize the approximating factors we select an approximating distribution from the exponential family to approximate the stochastic variables $\\theta$ $$ q(\\boldsymbol{\\theta})=\\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{\\mu}, \\mathbf{\\sigma_r^2}, \\mathbf{\\sigma_l^2}) = \\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{\\mu}, v_l \\mathbf{I}, v_r \\mathbf{I})\n= \\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{0}, b \\mathbf{I_l}, b \\mathbf{I_r}) $$\n$$ \\widetilde{f}_{n}(\\boldsymbol{\\theta})=s_n \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}n, \\mathbf{\\sigma{rn}^2}, \\mathbf{\\sigma{l_n}^2} \\right) = s_n \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}n, \\mathbf{v{rn} I}, \\mathbf{v{l_n} I} \\right) $$\n$$ sn = \\prod{d=1}^{D} \\sqrt{\\frac{2}{\\pi}} \\frac{1}{\\left(\\sigma{l{d}}+\\sigma{r{d}}\\right)} $$ While $\\sigma_{ln} \\rightarrow \\infty, \\sigma{r_n} \\rightarrow \\infty $ and $ \\mu_n = 0 $.\n###2. initialize the posterior approximation $q(\\boldsymbol{\\theta})$\nWe chooses the parameter values a = 10, b = 100 and w = 0.5 and use $v$ denote $ \\sigma^2$ as following, then $\\mathbf{v_r} = \\mathbf{v_l} = b = 100$\n3. Until all $(\\mun, v{ln}, v{r_n}, s_n)$ converge: $$ q^{\\backslash n}(\\boldsymbol{\\theta})=\\frac{q(\\boldsymbol{\\theta})}{\\widetilde{f}_n(\\boldsymbol{\\theta})} = \\frac{\\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{\\mu}, \\mathbf{v_r I}, \\mathbf{v_l I})}{s_n \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}n, \\mathbf{v{rn} I}, \\mathbf{v{l_n} I} \\right)} \\propto \\left{\\begin{array}{ll}\n{\\frac{\\exp \\left{-\\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mu})^{T}(v_l \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu})\\right}}{\\exp \\left{-\\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mun})^{T}(v{l_n} \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu_n})\\right}}} \u0026amp;\u0026amp; \\text { if } X\u0026lt;\\mu \\\n{\\frac{\\exp \\left{-\\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mu})^{T}(v_r \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu})\\right}}{\\exp \\left{-\\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mun})^{T}(v{r_n} \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu_n})\\right}}} \u0026amp;\u0026amp; \\text { if } X\u0026gt;\\mu\n\\end{array}\\right. \\\n= \\left{\\begin{array}{ll}\n\\exp \\left{-\\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mu})^{T}(v_l \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu}) + \\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mun})^{T}(v{l_n} \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu_n})\\right} \u0026amp; \\text { if } X\u0026lt;\\mu \\exp \\left{-\\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mu})^{T}(v_r \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu}) +\n\\frac{1}{2}(\\boldsymbol{X}-\\mathbf{\\mun})^{T}(v{r_n} \\mathbf{I})^{-1}(\\boldsymbol{X}-\\mathbf{\\mu_n}) \\right} \u0026amp; \\text { if } X\u0026gt;\\mu \\end{array}\\right. $$ - Remove the current estimate $\\widetilde{f}_j(\\boldsymbol{\\theta})$ from $q(\\theta)$, then we has mean and inverse variance given by: $$ \\left{\\begin{array}{ll} \\left({v_l}^{\\backslash n}\\right)^{-1}={v_l}^{-1}-{vl}{n}^{-1} \u0026amp; \\text { if } X\u0026lt;\\mu \\left({v_r}^{\\backslash n}\\right)^{-1}={v_r}^{-1}-{vr}{n}^{-1} \u0026amp; \\text { if } X\u0026gt;\\mu \\end{array}\\right. $$\n$$ \\mathbf{\\mu}^{\\backslash n}= \\mathbf{\\mu}+\n\\left{\\begin{array}{ll} {v_l}^{\\backslash n} {vl}{n}^{-1}\\left(\\mathbf{\\mu}-\\mathbf{\\mu}_{n}\\right) \u0026amp; \\text { if } X\u0026lt;\\mu \\\n{v_r}^{\\backslash n} {vr}{n}^{-1}\\left(\\mathbf{\\mu}-\\mathbf{\\mu}_{n}\\right) \u0026amp; \\text { if } X\u0026gt;\\mu \\\n\\end{array}\\right. $$ \u0026gt; Cavity Distribution: \u0026gt; $$ \u0026gt; q^{\\backslash j}(\\boldsymbol{\\theta})=\\frac{q(\\boldsymbol{\\theta})}{\\widetilde{f}_{j}(\\boldsymbol{\\theta})} \u0026gt; $$\n Recompute $(\\mu, v, Z)$ from $(\\mathbf{\\mu}^{\\backslash n}, {v_l}^{\\backslash n}, {vr}^{\\backslash n})$ $$ Z{n}=(1-w) \\mathcal{A}\\left(\\mathbf{x}_{n} | \\mathbf{\\mu}^{\\backslash n},\\left(v_l^{\\backslash n}+1\\right) \\mathbf{I}, \\left(vr^{\\backslash n}+1\\right) \\mathbf{I}\\right)+w \\mathcal{A}\\left(\\mathbf{x}{n} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{Ir}\\right) $$ \u0026gt;$$ \u0026gt;\\begin{aligned} \u0026gt;Z{n} \u0026amp;=\\int q^{\\backslash n}(\\boldsymbol{\\theta}) f{n}(\\boldsymbol{\\theta}) \\mathrm{d} \\boldsymbol{\\theta} \\ \u0026gt;\u0026amp;=\\int q^{\\backslash n}(\\boldsymbol{\\theta}) \\widetilde{f}{n}(\\boldsymbol{\\theta}) \\mathrm{d} \\boldsymbol{\\theta} \u0026gt; \u0026gt;\u0026amp;=\\int \\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{\\mu^{\\backslash n}}, v_l^{\\backslash n} \\mathbf{I}, v_r^{\\backslash n} \\mathbf{I}) \\cdot { (1-w) \\mathcal{A}(\\mathbf{x_n} | \\boldsymbol{\\mu}, \\mathbf{I_l}, \\mathbf{I_r})+w \\mathcal{A}(\\mathbf{x_n} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{I_r})} \\mathrm{d} \\boldsymbol{\\theta} \u0026gt; \u0026gt;\u0026amp;= (1-w)\\int \\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{\\mu^{\\backslash n}}, v_l^{\\backslash n} \\mathbf{I}, v_r^{\\backslash n} \\mathbf{I}) \\mathcal{A}(\\mathbf{x_n} | \\boldsymbol{\\mu}, \\mathbf{I_l}, \\mathbf{I_r}) \\mathrm{d} \\boldsymbol{\\theta} \u0026gt;\u0026amp;+ w \\int \\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{\\mu^{\\backslash n}}, v_l^{\\backslash n} \\mathbf{I}, v_r^{\\backslash n} \\mathbf{I}) \u0026gt;\\mathcal{A}(\\mathbf{x_n} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{Ir})} \\mathrm{d} \\boldsymbol{\\theta} \u0026gt;\u0026amp;=(1-w) \\mathcal{A}\\left(\\mathbf{x}{n} | \\mathbf{\\mu}^{\\backslash n},\\left(v_l^{\\backslash n}+1\\right) \\mathbf{I}, \\left(vr^{\\backslash n}+1\\right) \\mathbf{I}\\right)+w \\mathcal{A}\\left(\\mathbf{x}{n} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{I_r}\\right) \u0026gt;\\end{aligned} \u0026gt;$$  we assumed that $f{0}(\\boldsymbol{\\theta})=p(\\boldsymbol{\\theta})$ and $ f{n}(\\boldsymbol{\\theta})=p\\left(\\mathbf{x}_{n} | \\boldsymbol{\\theta}\\right) = (1-w) \\mathcal{A}(\\mathbf{X} | \\boldsymbol{\\mu}, \\mathbf{I_l}, \\mathbf{I_r})+w \\mathcal{A}(\\mathbf{X} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{I_r}) $, also $q(\\boldsymbol{\\theta})=\\mathcal{A}(\\boldsymbol{\\theta} | \\mathbf{m}, v_l \\mathbf{I}, vr \\mathbf{I}) $ $$ \\begin{aligned} \\rho{n} \u0026amp;=\\frac{1}{Z{n}}(1-w) \\mathcal{A}\\left(\\mathbf{x}{n} | \\mathbf{\\mu}^{\\backslash n},\\left(v_l^{\\backslash n}+1\\right) \\mathbf{I}, \\left(vr^{\\backslash n}+1\\right) \\mathbf{I}\\right) \u0026amp;= \\frac{1}{Z{n}}(1-w)\\cdot \\frac{Zn - w \\mathcal{A}\\left(\\mathbf{x}{n} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{I_r}\\right)}{1-w} \u0026amp;= 1 - \\frac{w}{Zn} \\cdot \\mathcal{A}\\left(\\mathbf{x}{n} | \\mathbf{0}, a \\mathbf{I_l}, a \\mathbf{Ir}\\right) \\end{aligned} $$ Basic rule for Asymmetric Gaussian: $$ \\nabla{\\boldsymbol{\\mu}} \\mathcal{A}(\\mathbf{x} | \\boldsymbol{\\mu}, \\mathbf{v_l}, \\mathbf{v_r})=\n\\left{\\begin{array}{ll}\n\\mathcal{A}(\\mathbf{x} | \\boldsymbol{\\mu}, \\mathbf{v_l}, \\mathbf{v_r}) \\cdot(\\mathbf{x}-\\boldsymbol{\\mu}) \\mathbf{v_l}^{-1} \u0026amp; \\text { if } X\u0026lt;\\mu \\\n\\mathcal{A}(\\mathbf{x} | \\boldsymbol{\\mu}, \\mathbf{v_l}, \\mathbf{v_r}) \\cdot(\\mathbf{x}-\\boldsymbol{\\mu}) \\mathbf{v_r}^{-1} \u0026amp; \\text { if } X\u0026gt;\\mu \\\n\\end{array}\\right. $$ So we compute the mean and variance: $$ \\mathbf{\\mu^{new}}=\\mathbf{\\mu}^{\\backslash n}+\n\\left{\\begin{array}{ll}\n\\rho_{n} \\frac{v_l^{\\backslash n}}{vl^{\\backslash n}+1}\\left(\\mathbf{x}{n}-\\mathbf{\\mu}^{\\backslash n}\\right) \u0026amp; \\text { if } X\u0026lt;\\mu \\\n\\rho_{n} \\frac{v_r^{\\backslash n}}{vr^{\\backslash n}+1}\\left(\\mathbf{x}{n}-\\mathbf{\\mu}^{\\backslash n}\\right) \u0026amp; \\text { if } X\u0026gt;\\mu \\\n\\end{array}\\right. $$\n$$ \\left{\\begin{array}{ll} v_l^{new}=vl^{\\backslash n}-\\rho{n} \\frac{\\left(v_l^{\\backslash n}\\right)^{2}}{vl^{\\backslash n}+1}+\\rho{n}\\left(1-\\rho_{n}\\right) \\frac{\\left(vl^{\\backslash n}\\right)^{2}\\left|\\mathbf{x}{n}-\\mathbf{m}^{\\backslash n}\\right|^{2}}{D\\left(v_l^{\\backslash n}+1\\right)^{2}} \u0026amp; \\text { if } X\u0026lt;\\mu \\\nv_r^{new}=vr^{\\backslash n}-\\rho{n} \\frac{\\left(v_r^{\\backslash n}\\right)^{2}}{vr^{\\backslash n}+1}+\\rho{n}\\left(1-\\rho_{n}\\right) \\frac{\\left(vr^{\\backslash n}\\right)^{2}\\left|\\mathbf{x}{n}-\\mathbf{m}^{\\backslash n}\\right|^{2}}{D\\left(v_r^{\\backslash n}+1\\right)^{2}} \u0026amp; \\text { if } X\u0026gt;\\mu \\\n\\end{array}\\right. $$ - Evaluate and store the new factor $$ \\left{\\begin{array}{ll} \\left({v_{l_n}}\\right)^{-1}={(v_l^{new})}^{-1}-({vl}^{\\backslash n})^{-1} \u0026amp; \\text { if } X\u0026lt;\\mu \\left({v{r_n}}\\right)^{-1}={(v_r^{new})}^{-1}-({v_r}^{ \\backslash n})^{-1} \u0026amp; \\text { if } X\u0026gt;\\mu \\end{array}\\right. $$\n$$ \\mathbf{m}_{n}=\\mathbf{m}^{\\backslash n}+ \\left{\\begin{array}{ll}\n\\left(v_{n}+v^{\\backslash n}\\right)\\left(v^{\\backslash n}\\right)^{-1}\\left(\\mathbf{m}^{\\mathrm{new}}-\\mathbf{m}^{\\backslash n}\\right) \u0026amp; \\text { if } X\u0026lt;\\mu \\\n\\left(v_{n}+v^{\\backslash n}\\right)\\left(v^{\\backslash n}\\right)^{-1}\\left(\\mathbf{m}^{\\mathrm{new}}-\\mathbf{m}^{\\backslash n}\\right) \u0026amp; \\text { if } X\u0026gt;\\mu \\\n\\end{array}\\right. $$\n$$ \\begin{aligned} \u0026amp; \\widetilde{f}{n}(\\boldsymbol{\\theta})=Z{n} \\frac{q^{\\mathrm{new}}(\\boldsymbol{\\theta})}{q^{\\backslash n}(\\boldsymbol{\\theta})} \\\n\\Rightarrow \u0026amp; Z_n q^{\\mathrm{new}}(\\boldsymbol{\\theta}) = s_n \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}n, \\mathbf{v{rn} I}, \\mathbf{v{l_n} I} \\right) q^{\\backslash n}(\\boldsymbol{\\theta}) = s_n \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}n, \\mathbf{v{rn} I}, \\mathbf{v{l_n} I} \\right) \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}^{\\backslash n}, \\mathbf{v_r^{\\backslash n} I}, \\mathbf{v_l^{\\backslash n} I} \\right) \\\n\\Rightarrow \u0026amp; \\int Z_n q^{\\mathrm{new}}(\\boldsymbol{\\theta}) d\\theta = \\int s_n \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}n, \\mathbf{v{rn} I}, \\mathbf{v{l_n} I} \\right) \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}^{\\backslash n}, \\mathbf{v_r^{\\backslash n} I}, \\mathbf{v_l^{\\backslash n} I} \\right) d \\theta \\\n\\Rightarrow \u0026amp; Z_n = s_n \\int q^{\\mathrm{new}}(\\boldsymbol{\\theta}) d\\theta =\n\\int s_n \\mathcal{A}\\left( \\mathbf{\\mu}n - \\boldsymbol{\\theta} | 0, \\mathbf{v{rn} I}, \\mathbf{v{l_n} I} \\right) \\mathcal{A}\\left(\\boldsymbol{\\theta} | \\mathbf{\\mu}^{\\backslash n}, \\mathbf{v_r^{\\backslash n} I}, \\mathbf{v_l^{\\backslash n} I} \\right) d \\theta \\\n\\Rightarrow \u0026amp; Z_n = s_n \\mathcal{A}\\left(\\mathbf{\\mu}_n | \\mathbf{\\mu}^{\\backslash n}, \\mathbf{(vr^{\\backslash n}+ v{r_n}) I}, \\mathbf{(vl^{\\backslash n}+v{r_n}) I} \\right) \\end{aligned} $$\n$$ s_n = \\frac{Z_n} {\\mathcal{A}\\left(\\mathbf{\\mu}_n | \\mathbf{\\mu}^{\\backslash n}, \\mathbf{(vr^{\\backslash n}+ v{r_n}) I}, \\mathbf{(vl^{\\backslash n}+v{r_n}) I} \\right)} $$\n","date":1582994068,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584657777,"objectID":"985b28a7398b99c38e892b86d015b478","permalink":"https://faithio.cn/post/stochastic-expectation-propagation/","publishdate":"2020-02-29T11:34:28-05:00","relpermalink":"/post/stochastic-expectation-propagation/","section":"post","summary":"Math Formula Factor graphs Shows how a function of several variables can be factored into a product of simpler functions.\n $$ f(x,y,z) = (x+y) \\cdot (y + z) \\cdot (x +z) $$\n Very useful for representing posteriors.\n$ $$ P(x1, ..., x_n) = P(x_1) \\Pi P( x_i | x_{i-1} ) $$ $\n$$ P(m|x1, \u0026hellip;, x_n) = P(m) \\cdot \\Pi P(x_i|m)$$\nmodeling  What graph should I use for this data?","tags":[],"title":"Stochastic Expectation Propagation","type":"post"},{"authors":[],"categories":[],"content":" Introduction A hypothesis h(x), takes an input and gives us the estimated output value.\nThis hypothesis can be a as simple as a one variable linear equation, .. up to a very complicated and long multivariate equation with respect to the type of the algorithm we’re using (i.e. linear regression, logistic regression..etc).\nOur task is to find the best Parameters (a.k.a Thetas or Weights) that give us the least error in predicting the output. We call this error a Cost or Loss Function and apparently our goal is to minimize it in order to get the best predicted output!\nOne more thing to recall, that the relation between the parameter value and its effect on the cost function (i.e. the error) looks like a bell curve (i.e. Quadratic; recall this because it’s very important) .\nSo if we start at any point in that curve and if we keep taking the derivative (i.e. tangent line) of each point we stop at, we will end up at what so called the Global Optima as shown in this image: If we take the partial derivative at minimum cost point (i.e. global optima) we find the slope of the tangent line = 0 (then we know that we reached our target).\nThat’s valid only if we have Convex Cost Function, but if we don’t, we may end up stuck at what so called Local Optima; consider this non-convex function:\nNow you should have the intuition about the hack relationship between what we are doing and the terms: Deravative, Tangent Line, Cost Function, Hypothesis ..etc.\nSide Note: The above mentioned intuition also related to the Gradient Descent Algorithm (see later).\nBackground Linear Approximation:\nGiven a function, f(x), we can find its tangent at x=a. The equation of the tangent line L(x) is: L(x)=f(a)+f′(a)(x−a).\nTake a look at the following graph of a function and its tangent line:\nFrom this graph we can see that near x=a, the tangent line and the function have nearly the same graph. On occasion we will use the tangent line, L(x), as an approximation to the function, f(x), near x=a. In these cases we call the tangent line the linear approximation to the function at x=a.\nQuadratic Approximation:\nSame like linear approximation but this time we are dealing with a curve but we cannot find the point near to 0 by using the tangent line.\nInstead, we use a parabola (which is a curve where any point is at an equal distance from a fixed point or a fixed straight line), like this:\nAnd in order to fit a good parabola, both parabola and quadratic function should have same value, same first derivative, AND second derivative, \u0026hellip; the formula will be (just out of curiosity): Qa(x) = f(a) + f'(a)(x-a) + f''(a)(x-a)2/2\nNow we should be ready to do the comparison in details.\nComparison between the methods 1. Newton’s Method(newton-cg): Recall the motivation for gradient descent step at x: we minimize the quadratic function (i.e. Cost Function).\nNewton’s method uses in a sense a better quadratic function minimisation. A better because it uses the quadratic approximation (i.e. first AND second partial derivatives).\nYou can imagine it as a twisted Gradient Descent with The Hessian (The Hessian is a square matrix of second-order partial derivatives of order nxn).\nMoreover, the geometric interpretation of Newton\u0026rsquo;s method is that at each iteration one approximates f(x) by a quadratic function around xn, and then takes a step towards the maximum/minimum of that quadratic function (in higher dimensions, this may also be a saddle point). Note that if f(x) happens to be a quadratic function, then the exact extremum is found in one step.\nDrawbacks:\n It’s computationally expensive because of The Hessian Matrix (i.e. second partial derivatives calculations). It attracts to Saddle Points which are common in multivariable optimization (i.e. a point its partial derivatives disagree over whether this input should be a maximum or a minimum point!).  2. Limited-memory Broyden–Fletcher–Goldfarb–Shanno Algorithm(lbfgs): In a nutshell, it is analogue of the Newton’s Method but here the Hessian matrix is approximated using updates specified by gradient evaluations (or approximate gradient evaluations). In other words, using an estimation to the inverse Hessian matrix.\nThe term Limited-memory simply means it stores only a few vectors that represent the approximation implicitly.\nIf I dare say that when dataset is small, L-BFGS relatively performs the best compared to other methods especially it saves a lot of memory, however there are some “*serious*” drawbacks such that if it is unsafeguarded, it may not converge to anything.\n3. A Library for Large Linear Classification(liblinear): It’s a linear classification that supports logistic regression and linear support vector machines (A linear classifier achieves this by making a classification decision based on the value of a linear combination of the characteristics i.e feature value).\nThe solver uses a coordinate descent (CD) algorithm that solves optimization problems by successively performing approximate minimization along coordinate directions or coordinate hyperplanes.\nLIBLINEAR is the winner of ICML 2008 large-scale learning challenge. It applies Automatic parameter selection (a.k.a L1 Regularization) and it’s recommended when you have high dimension dataset (recommended for solving large-scale classification problems)\nDrawbacks:\n It may get stuck at a non-stationary point (i.e. non-optima) if the level curves of a function are not smooth. Also cannot run in parallel. It cannot learn a true multinomial (multiclass) model; instead, the optimization problem is decomposed in a “one-vs-rest” fashion so separate binary classifiers are trained for all classes.  Side note: According to Scikit Documentation: The “liblinear” solver is used by default for historical reasons.\n4. Stochastic Average Gradient(sag): SAG method optimizes the sum of a finite number of smooth convex functions. Like stochastic gradient (SG) methods, the SAG method\u0026rsquo;s iteration cost is independent of the number of terms in the sum. However, by incorporating a memory of previous gradient values the SAG method achieves a faster convergence rate than black-box SG methods.\nIt is faster than other solvers for large datasets, when both the number of samples and the number of features are large.\nDrawbacks:\n It only supports L2 penalization. Its memory cost of O(N), which can make it impractical for large N (because it remembers the most recently computed values for approx. all gradients).  5. SAGA(saga): The SAGA solver is a variant of SAG that also supports the non-smooth penalty=l1 option (i.e. L1 Regularization). This is therefore the solver of choice for sparse multinomial logistic regression and it’s also suitable very Large dataset.\nSide note: According to Scikit Documentation: The SAGA solver is often the best choice.\nSummary The following table is taken from Scikit Documentation\n","date":1582962364,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584657777,"objectID":"25e50f2219880ef0b8c0c1f286c67275","permalink":"https://faithio.cn/post/logistic-regression-solvers-defintions-in-sklearn/","publishdate":"2020-02-29T02:46:04-05:00","relpermalink":"/post/logistic-regression-solvers-defintions-in-sklearn/","section":"post","summary":"Introduction A hypothesis h(x), takes an input and gives us the estimated output value.\nThis hypothesis can be a as simple as a one variable linear equation, .. up to a very complicated and long multivariate equation with respect to the type of the algorithm we’re using (i.e. linear regression, logistic regression..etc).\nOur task is to find the best Parameters (a.k.a Thetas or Weights) that give us the least error in predicting the output.","tags":[],"title":"Logistic Regression   Solvers' Defintions in Sklearn","type":"post"}]